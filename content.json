{"meta":{"title":"SevenHsu","subtitle":null,"description":null,"author":"Seven Hsu","url":"https://sevenhsu.github.io"},"pages":[],"posts":[{"title":"linux开启ssh服务","slug":"2019_03_28_18","date":"2019-03-28T03:43:09.606Z","updated":"2019-03-28T03:43:09.607Z","comments":true,"path":"2019/03/28/2019_03_28_18/","link":"","permalink":"https://sevenhsu.github.io/2019/03/28/2019_03_28_18/","excerpt":"","text":"1 基本描述 在自己的linux服务器上配置ssh服务器，添加新用户并通过ssh连接服务器 2 安装ssh服务并配置 通过命令service sshd status查看ssh服务器状态，如果自己的服务器上已经安装了ssh服务器，则跳过此步骤 通过以下命令安装ssh服务器 123sudo apt-get install openssh-server#或者使用yum 安装sudo yum install openssh-server 编辑/etc/ssh/sshd_config文件配置ssh 12PermitRootLogin yes # 是否允许root通过ssh认证PasswordAuthentication no # 是否允许使用密码认证 3 添加用户并配置用户的ssh认证 通过以下命令添加新用户，根据自己的需要配置参数 添加新用户的命令 123456useradd [-d home] [-s shell] [-c comment] [-m] [-r] name# -d /home/username：设置用户登入时的主目录# -s /bin/bash：用户登入时使用的shell# -c comment：备注# -m 用户目录不存在时，自动建立用户的登入目录# -r 建立系统账号 提升用户权限 将用户提升到sudoers权限，编辑/etc/sudoers 123sudo vim /etc/sudoers# 配置如下：在root ALL=(ALL:ALL) ALL下添加一行username ALL=(ALL) ALL 用户在本地生成自己的ssh密钥对 安装git，使用git bash下执行ssh-keygen -t rsa -C &quot;youremail@example.com&quot;生成自己的密钥对生成的密钥对位置：Windows在C:/Users/username/.ssh,Mac os在/home/username/.ssh 将自己.ssh/id_rsa.pub的内容复制到服务器/home/username/.ssh/authorized_keys文件里。其中username为新建用户的名字，/home/username/.ssh/authorized_keys路径不存在就自己建立文件夹和文件。 新建.ssh文件夹和authorized_keys文件 12sudo mkdir .ssh # 建立.ssh文件夹sudo vim authorized_keys # 将自己的公钥(id_rsa.pub)内容写进去 配置文件和文件夹权限 123sudo chmod 600 /home/username/.ssh/authorized_keys # 设置authorized_keys的权限为600sudo chmod 700 /home/username/.ssh # 设置.ssh的权限为700sudo chown -R username. /home/username # 设置username文件夹的拥有者为username 配置好一切后，用户在本地终端使用ssh serverhost即可连接到服务器。","categories":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://sevenhsu.github.io/tags/ssh/"},{"name":"linux","slug":"linux","permalink":"https://sevenhsu.github.io/tags/linux/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}]},{"title":"ResNet","slug":"2019_03_19_10","date":"2019-03-23T13:09:36.185Z","updated":"2019-03-23T13:09:36.185Z","comments":true,"path":"2019/03/23/2019_03_19_10/","link":"","permalink":"https://sevenhsu.github.io/2019/03/23/2019_03_19_10/","excerpt":"","text":"1 基本描述 原始论文： Deep Residual Learning for Image Recognition 论文复现：ResNet-TensorFlow 2 背景问题 ResNet的提出是为了解决深层网络难训练的问题 CNN在图像特征提取方面有非常好的拓展性，增加网络深度可以提取更多的特征，越深的层 提取的特征越抽象，越具有语义信息。 直接增加网络的层数会导致梯度消失或梯度爆炸等问题是的模型训练失败。 在模型中增加正则化和在模型中间增加BN(batch normalization)可避免梯度消失和梯度爆炸等问题，使得模型可训练。 虽然增加正则和BN层的模型可训练，但是深层模型在训练时出现了收敛退化的问题，ResNet作者通过实验证明通过多次迭代训练是无法解决对话问题的。 3 网络结构 作者为了解决深层网络难以训练的问题，提出了残差学习，在深层的训练的时候，将输入的feature map加上浅层的feature map特征。ResNet的网络结构借鉴了VGG的网络结构，在第一层使用了7*7的大尺寸卷积核，在后面的卷积block中都使用了细小的卷积核。 3.1 残差函数 图3.1 残差学习block 残差函数 $$H(x)=F(x)+x$$ F(x)可以用前向传播shortcut connection(shortcut connection)。 shortcut connection就是如图所示跳过一层或多层的连接，在resnet中这个shortcut connection是简单的将恒等mapping 加上当前层的输出。恒等的shortcut connection即没有增加额外的参数也没有增加计算复杂度，所以整个网络依然是可以端到端训练的。 3.2 shortcut connection ResNet文章中作者提出shortcut connection的方式有三种 A：zero-padding，没有额外的参数。在mapping的四周填充0 B：使用1*1的卷积投影增加shortcut维度，不需要改变尺寸和维度的恒等不变 C：全部shortcut使用1*1的卷积投影 A、B、C三种方式的优缺点主要体现在时间复杂度上，A的参数量 &lt; B的参数量 &lt; C的参数量。由于C对全部的shortcut都使用了1*1的卷积投影，导致训练时间上近乎是B的两倍。作者通过实验分析得到C的效果略微优于A和B，这是优于C在1*1的卷积上也学到了一些特征 3.3 bottleneck 考虑到更深的网络能够承受的训练时长，作者对深层网络将block改成了Bottleneck的设计对于残差函数F(x) ，使用堆叠的3层卷积网络替换block的2层，3层分别是1*1，3*3，1*1。其中的1*1的卷积是负责消减和扩展维度的。 non-Bottleneck和Bottleneck 图3.2 non-bottleneck和bottleneck结构 图3.2左侧的是non-Bottleneck结构，shortcut connection跳过的是两个3*3的卷积。右侧是bottleneck的结构。 多层ResNet结构 表3.1 在ImageNet分类任务上的网络结构 表3.1是基于ImageNet分类任务的ResNet网络结构，输入是224*224放入图片。 图3.3 VGG19/普通深层网络/ResNet深层网络对比 右侧是34层的ResNet网络结构图，图中的实线恒等连接，虚线是需要做维度变换的，用到的方法就是上面的A、B、C三种。 4 实现工作4.1 数据预处理ResNet在实验上对图片的处理借鉴了VGG的方法，将图片缩放到[256,480]之间的随机尺寸，然后在缩放的图片之间随机裁剪尺寸为224*224的图片，这样也起到了数据增强的作用。在测试和预测的时候可以采用同样的方式随机裁剪多张图片，取预测结果的众数。 网络搭建在卷积层之后添加BN层可以防止过拟合，每一个卷积block开始训练前保存输入，在block训练后做shortcut connection，在连接的时候考虑feature map和保存的输入维度是否一致，不一致使用上文的A、B、C三种方法做放缩。 4.2 在CIFAR-10的实验分析 数据预处理，网络的输入是32*32,每个像素减去平均值。第一层是3*3的卷积,然后一共使用堆叠 6n层3*3的卷积，feature map size分别为{32,16,8},每个feature map size堆叠2n层。 卷积核的数量是{16,32,64},作者在实验中测试了n={3,5,7,9}，结果error大概在7左右。 5 总结总体上来说ResNet的网络结构并不复杂，但是提出残差学习这点，并且使得深层网络可训练简直是一次技术上的革命。ResNet基础网络大部分借鉴了VGG，其中的first convolution和后面block里的3*3的细小卷积核和使用随机裁剪的图像处理方法。ResNet的重点在于残差学习，这使得训练的深层网络在ImageNet等比赛中取得了冠军。 参考资料 ResNet 残差网络ResNet笔记","categories":[{"name":"CV","slug":"CV","permalink":"https://sevenhsu.github.io/categories/CV/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://sevenhsu.github.io/tags/tensorflow/"},{"name":"python","slug":"python","permalink":"https://sevenhsu.github.io/tags/python/"}],"keywords":[{"name":"CV","slug":"CV","permalink":"https://sevenhsu.github.io/categories/CV/"}]},{"title":"如何在服务器上使用Tensorboard","slug":"2019_03_09_14","date":"2019-03-19T08:44:39.777Z","updated":"2019-03-19T08:44:39.777Z","comments":true,"path":"2019/03/19/2019_03_09_14/","link":"","permalink":"https://sevenhsu.github.io/2019/03/19/2019_03_09_14/","excerpt":"","text":"方法一 在服务器上启动Tensorboard，保证本地主机能够正常访问服务器下，在本地访问服务器IP:Tensorboard所在端口 服务器上启动Tensorboard 12tensorboard --logdir your_logdir_path --port 8000# your_logdir_path:你的tensorflow训练日志文件夹 本地浏览器访问 比如服务器IP为10.0.1.12,在本地浏览器访问10.0.1.12:8000就可以了。 方法二 在服务器上启动Tensorboard，将服务器端口映射到本地主机上，在本地访问localhost:映射的端口 内网映射： 12345ssh -L local_port:127.0.0.1:server_port username@server_ip# local_port:映射到本地的端口号# server_port:服务器的映射端口号# username:访问服务器的用户名# server_ip:服务器IP 外网映射 123456ssh -p telnet_port -L local_port:127.0.0.1:server_port username@server_ip# telnet_port:远程连接端口# local_port:映射到本地的端口号# server_port:服务器的映射端口号# username:访问服务器的用户名# server_ip:服务器IP 服务器上启动Tensorboard 1tensorboard --logdir your_logdir_path --port server_port 本地浏览器访问 本地浏览器访问127.0.0.1:local_port","categories":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://sevenhsu.github.io/tags/tensorflow/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}]},{"title":"github+hexo搭建个人博客","slug":"2019_03_09_16","date":"2019-03-09T15:44:07.509Z","updated":"2019-03-09T15:44:07.509Z","comments":true,"path":"2019/03/09/2019_03_09_16/","link":"","permalink":"https://sevenhsu.github.io/2019/03/09/2019_03_09_16/","excerpt":"","text":"1 基本描述 项目存储：使用Github来存放个人博客项目,并使用Github的pages服务使个人博客能够被浏览器访问(http请求)。 项目创建：使用node.js的npm下载安装Hexo,使用Hexo生成博客项目 项目管理：使用git管理项目版本和推送项目到Github 博客评论：使用gittalk实现博客留言 访问统计：使用腾讯分析提供的接口统计博客的访问量和访客数 2 所需资源 Github:面向开源及私有软件项目的托管平台，供存放博客项目。需注册自己的账号 git一个开源的分布式版本控制系统,用于管理项目版本和将本地代码推送至Github平台，需下载安装 Node.js:一个让 JavaScript 运行在服务端的开发平台,需要下载并安装在本机 NPM:(node.js package manager)是随同NodeJS一起安装的包管理工具，可用于下载第三方包，能解决NodeJS代码部署上的很多问题，无需单独下载安装 Hexo:一款使用node.js开发的简单、极速、强大的博客框架，用于快速生成的博客 Gittalk一个基于 GitHub Issue 和 Preact 开发的评论插件,需在支持Gittalk的主题中配置相关信息，也可在不支持的主题中增加Gittalk插件 腾讯分析用于统计访问量和访客数，需注册并添加自己博客的站点 3 资源准备3.1 下载安装git 点击这里下载对应版本git并安装 安装git后生成自己的ssh密钥对，用于github的认证。在终端(Mac os/Linux)或者cmd(Windows)执行以下命令生成ssh密钥 123ssh-keygen -t rsa -C \"youremail@example.com\"# -t:指定密钥类型，默认rsa# -C:指定注释，用于标示密钥，内容任意 3.2 下载安装node.js 点击这里下载对应版本node.js 3.3 下载安装Hexo 安装node.js后在终端(Mac os/Linux)或者cmd(Windows)执行以下命令安装Hexo 1npm install hexo-cli -g 4 博客搭建4.1 注册Github平台账号并创建博客项目仓库4.1.1 注册Github 点击这里到注册页面进行注册 注册完成后，将个人本地的ssh公钥添加到自己Github账号中。打开.ssh-&gt;id_rsa.pub(.shh文件夹在不同系统存放路径不一致) 在个人Github账号Settings-&gt;SSH and GPG keys下新建SSH key，复制id_rsa.pub文件中内容粘贴到key中 4.1.2 创建博客项目仓库 登录到Github，并创建个人博客仓库(标记为：远程仓库) 新建仓库，填写仓库名和描述。仓库名须为github_name.github.io的形式，其中github_name为个人github账户名 仓库创建完成后，需要将github上的仓库克隆到本地，复制你的仓库ssh地址 在终端或cmd下进入想克隆的路径下使用以下命令克隆,请记住这个文件夹(标记为：本地仓库)的位置 1git clone git@github.com:github_name/guthub_name.github.io.git 4.2 生成本地博客项目并推送至远程仓库 使用Hexo生成博客项目，最后将博客项目文件夹内的所有文件&amp;文件夹拷贝至本地仓库 4.2.1 生成博客项目 在终端或cmd下进入想存放的路径，执行以下命令即可完成博客项目(博客网站)的生成 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 4.2.2 本地预览博客 在将博客项目内的所有文件&amp;文件夹拷贝至本地仓库后，在终端或cmd下进入本地仓库根目录下执行以下命令启动博客的http服务。然后在浏览器中访问localhost:4000 1hexo server 4.2.3 推送博客项目至远程仓库 打开本地仓库根目录下的_config.yml文件，在文件的最后配置部署信息 完成部署配置后，在终端或cmd下进入本地仓库根目录下执行以下命令将本地仓库推送到远程仓库。然后访问http://github_name.github.io 即可访问远程仓库上的博客 123hexo clean # 清除缓存hexo generate # 生成静态文件hexo deploy # 部署到远程仓库 5 评论插件 使用Gittalk插件将评论存放在指定的仓库下,获取用于认证存放评论的Client ID 和 Client Secret 5.1 注册Github APP 在个人Github-&gt;Settings-&gt;Developer Settings下新建一个OAuth App并获取Client ID和Client Secret。此处红框中需要填写你的博客地址https://github_name.github.io 下面是Client ID和Client Secret 5.2 配置Gittalk插件 打开本地仓库根目录-&gt;themes-&gt;(theme_folder)-&gt;_config.yml配置Gittalk，其中Client ID 和 Client Secret是前面得到的，repo是存放评论的仓库名，owner是仓库的所有者，admin是仓库的管理者 5.3 初始化评论 由于评论存储在github仓库issue中，没有任何文章的信息，所以需要先对每个文章初始化一个评论，后续的评论将会依附在初始评论下 5.3.1 获取初始化评论的token 点击这里创建access token用于初始化认证,选中红框内的条目，描述随意填写 复制你的access token，之后将不在显示 5.3.2 添加自动初始化脚本 在本地仓库根目录下新建comment.js文件，将以下js代码粘贴到comment.js文件中，脚本将会在部署的时候自动初始化评论。请注意替换脚本中的帐户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const request = require(\"request\");const fs = require(\"fs\");const path = require(\"path\");const url = require(\"url\");const xmlParser = require(\"xml-parser\");const YAML = require(\"yamljs\");const cheerio = require(\"cheerio\");// 根据自己的情况进行配置const config = &#123; username: \"github_name\", // GitHub 用户名 token: \"824c5d68b801b4255f0738cb91e0f893c443739f\", // GitHub Token repo: \"github_name.github.io\", // 存放 issues的git仓库 // sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理 sitemapUrl: path.resolve(__dirname, \"./public/sitemap.xml\"), kind: \"Gitalk\", // \"Gitalk\" or \"Gitment\"&#125;;let issuesUrl = `https://api.github.com/repos/$&#123;config.username&#125;/$&#123;config.repo&#125;/issues?access_token=$&#123;config.token&#125;`;let requestGetOpt = &#123; url: `$&#123;issuesUrl&#125;&amp;page=1&amp;per_page=1000`, json: true, headers: &#123; \"User-Agent\": \"github-user\" &#125;&#125;;let requestPostOpt = &#123; ...requestGetOpt, url:issuesUrl, method: \"POST\", form: \"\"&#125;;console.log(\"开始初始化评论...\");(async function() &#123; console.log(\"开始检索链接，请稍等...\"); try &#123; let websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, \"./_config.yml\"), \"utf8\")); let urls = sitemapXmlReader(config.sitemapUrl); console.log(`共检索到$&#123;urls.length&#125;个链接`); console.log(\"开始获取已经初始化的issues:\"); let issues = await send(requestGetOpt); console.log(`已经存在$&#123;issues.length&#125;个issues`); let notInitIssueLinks = urls.filter((link) =&gt; &#123; return !issues.find((item) =&gt; &#123; link = removeProtocol(link); return item.body.includes(link); &#125;); &#125;); if (notInitIssueLinks.length &gt; 0) &#123; console.log(`本次有$&#123;notInitIssueLinks.length&#125;个链接需要初始化issue：`); console.log(notInitIssueLinks); console.log(\"开始提交初始化请求, 大约需要40秒...\"); /** * 部署好网站后，直接执行start，新增文章并不会生成评论 * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤 */ setTimeout(async ()=&gt;&#123; let initRet = await notInitIssueLinks.map(async (item) =&gt; &#123; let html = await send(&#123; ...requestGetOpt, url: item &#125;); let title = cheerio.load(html)(\"title\").text(); let pathLabel = url.parse(item).path; let body = `$&#123;item&#125;&lt;br&gt;&lt;br&gt;$&#123;websiteConfig.description&#125;`; let form = JSON.stringify(&#123; body, labels: [config.kind, pathLabel], title &#125;); return send(&#123; ...requestPostOpt, form &#125;); &#125;); console.log(`已完成$&#123;initRet.length&#125;个！`); console.log(\"可以愉快的发表评论了！\"); &#125;,40000); &#125; else &#123; console.log(\"本次发布无新增页面，无需初始化issue!!\"); &#125; &#125; catch (e) &#123; console.log(`初始化issue出错，错误如下：`); console.log(e); &#125; finally &#123; &#125;&#125;)();function sitemapXmlReader(file) &#123; let data = fs.readFileSync(file, \"utf8\"); let sitemap = xmlParser(data); return sitemap.root.children.map(function (url) &#123; let loc = url.children.filter(function (item) &#123; return item.name === \"loc\"; &#125;)[0]; return loc.content; &#125;);&#125;function removeProtocol(url) &#123; return url.substr(url.indexOf(\":\"));&#125;function send(options) &#123; return new Promise(function (resolve, reject) &#123; request(options, function (error, response, body) &#123; if (!error) &#123; resolve(body); &#125; else &#123; reject(error); &#125; &#125;); &#125;);&#125; 5.3.3 一行命令部署 在终端或cmd进入本地仓库根目录下，执行之前部署到远程的命令加上初始化评论的命令即可将可评论的新版本推送到线上 跳过，直接一行命令部署 1234hexo clean # 清除缓存hexo generate # 生成静态文件hexo deploy # 部署到远程仓库node ./comment.js # 初始化评论 首先将上面的多行命令按json的格式添加到本地仓库根目录下的package.json文件末尾 多行命令的json格式 1234\"scripts\": &#123; \"deploy\": \"hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node ./comment.js\" &#125; 一行命令部署,后续博客的修改、文章的发布后只需要执行这一行命令即可更新发布到远程仓库 1npm run deploy 6 访问量统计 点击这里注册腾讯分析账号，在个人-&gt;站点列表中添加站点(博客地址) 然后将站点统计的ID放到博客所用的主题下的_config.yml文件对应的腾讯统计下，也可以自己将统计的代码放到博客网页中 1&lt;script type=\"text/javascript\" src=\"https://tajs.qq.com/stats?sId=ID\" charset=\"UTF-8\"&gt;&lt;/script&gt; 7 更换主题和更新文章7.1 更换主题 可在Hexo官网下载自己感兴趣的主题 将主题文件夹放在本地仓库根目录下的themes文件夹下 修改本地仓库根目录下的_config.yml文件中的themes 7.2 更新文章 只需将新的markdown类型的文章放置在本地仓库根目录下的sources-&gt;_posts文件夹下即可 须注意在文章开头要标明文章标题、所属分类、以及标签。格式如下 12345678---title: HelloWorldtags: - hello - blogcategories: - Other--- 8 注意事项 文章的github_name为自己的Github用户名 博客根目录和主题文件夹下都存在source文件夹和_config.yml文件，注意区分 对本地博客项目做了修改后，需要执行一行命令才会推送到远程仓库上 可在个人Github远程仓库(存放博客项目)的设置下的pages服务中开启https 本文章案例所用的主题为snippet 可根据自己的兴趣增加博客的功能，具体设置在博客项目根目录下的_config.yml和主题根目录下的_config.yml 可根据自己的兴趣修改博客页面 参考资料 Hexo官方文档 snippet nodejs版本的Gitalk/Gitment评论自动初始化","categories":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://sevenhsu.github.io/tags/HTML/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://sevenhsu.github.io/categories/Other/"}]}]}